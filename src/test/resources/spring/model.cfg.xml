<?xml version="1.0" encoding="UTF-8"?>

<!--
===============================================================================
Example of Aloha factory and model creation.  This uses the factory class
com.eharmony.matching.aloha.interop.NoImplModelFactory which tossed away
implementation details of the models that it creates.  While this is better for
a java environment because it's easier and higher kinds don't really work in
java, this isn't the preferred way to create model factories in code using
mixins, cake pattern, etc.


===============================================================================
-->
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd">

    <bean id="placeholderConfig" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>classpath:mvn_gen_test.properties</value>             <!-- Properties generated by maven. -->
                <value>classpath:spring_test/spring_test.properties</value>
            </list>
        </property>
    </bean>

    <!-- Apache VFS manager used to create files to pass to factory for parsing. -->
    <bean id="vfs2FileManager" class="org.apache.commons.vfs2.VFS" factory-method="getManager" />


    <!-- Execution context is required for the multi-threaded caching implementation. -->
    <util:constant id="execContextFactory" static-field="scala.concurrent.ExecutionContext$.MODULE$" />
    <bean id="execContext" factory-bean="execContextFactory" factory-method="global" />

    <!--
    **********************************   THIS DEFINES THE INPUT TYPE OF THE MODEL!   **********************************
        A few objects need a java.lang.Class object for the input type to the model.  This is only a class versus
        something more powerful because we are using a protocol buffer GeneratedMessage as the model input type and
        GeneratedMessage instances are not parametrized.
    **********************************   THIS DEFINES THE INPUT TYPE OF THE MODEL!   **********************************
    -->
    <bean id="modelInputTypeProtoClass" class="java.lang.Class" factory-method="forName">
        <constructor-arg value="${model_input_type}"/>
    </bean>

    <!-- *************************************************************************************************** -->
    <!--                                       CREATE SEMANTICS HERE ...                                     -->
    <!-- *************************************************************************************************** -->
    <!--
        The compiled semantics plugin.  This plugin is responsible for generating the code to extract data from
        the protocol buffer GeneratedMessage.
     -->
    <bean id="userPairingProtoPlugin"
          class="com.eharmony.matching.aloha.semantics.compiled.plugin.proto.CompiledSemanticsProtoPlugin">
        <constructor-arg index="0" type="java.lang.Class" ref="modelInputTypeProtoClass" />
    </bean>

    <!--
        The compiler that is responsible for compiling the code produced in the compiled semantics.  By providing
        a java.io.File to the constructor, we are instructing the compiler to cache, on disk, the byte code.  This
        dramatically improves model creation speed on loads following the first load.  Additionally, since model
        features are compiled independently, they can be reused across models.
    -->
    <bean id="compiler"
          class="com.eharmony.matching.aloha.semantics.compiled.compiler.TwitterEvalCompiler">
        <constructor-arg index="0" type="java.io.File">
            <bean class="java.io.File">
                <constructor-arg index="0" type="java.lang.String" value="${testGeneratedClasses}" />
            </bean>
        </constructor-arg>
    </bean>

    <!--
        Semantics produce the functions injected into models.  The third argument is important.  It specifies the
        functionality that is imported.  This should be a String[].  At the very least, this should be:

            com.eharmony.matching.aloha.feature.BasicFunctions._
    -->
    <bean id="semantics" class="com.eharmony.matching.aloha.semantics.compiled.CompiledSemantics">
        <constructor-arg index="0" ref="compiler" />
        <constructor-arg index="1" ref="userPairingProtoPlugin" />
        <constructor-arg index="2" value="${semantics_imports}" />
        <constructor-arg index="3" ref="execContext" />
    </bean>

    <!-- *************************************************************************************************** -->
    <!--                                        CREATE FACTORY HERE ...                                      -->
    <!-- *************************************************************************************************** -->
    <!-- OK to use the java.lang.Class-based ctor b/c the type is not parametrized. -->
    <bean id="doubleFactoryInfo" class="com.eharmony.matching.aloha.interop.DoubleFactoryInfo">
        <constructor-arg index="0" type="java.lang.Class" ref="modelInputTypeProtoClass" />
    </bean>

    <!-- Create a java.lang.Iterable of parsers.  Dictates the types of models that can be produced by the factory. -->
    <bean id="parsers" class="java.util.ArrayList">
        <constructor-arg>
            <list>
                <bean class="com.eharmony.matching.aloha.models.reg.RegressionModel" factory-method="parser"/>
            </list>
        </constructor-arg>
    </bean>

    <bean id="untypedModelFactory" class="com.eharmony.matching.aloha.factory.ModelFactory">
        <constructor-arg index="0" ref="parsers" />
    </bean>

    <bean id="modelFactory" factory-bean="untypedModelFactory" factory-method="toTypedFactory">
        <constructor-arg index="0" type="com.eharmony.matching.aloha.semantics.Semantics" ref="semantics" />
        <constructor-arg index="1" type="com.eharmony.matching.aloha.interop.FactoryInfo" ref="doubleFactoryInfo" />
    </bean>

    <!-- *************************************************************************************************** -->
    <!--                                      CREATE FIRST MODEL HERE ...                                    -->
    <!-- *************************************************************************************************** -->
    <!-- Construct model using the Apache VFS FileObject interface. -->
    <!-- The actual file object containing the JSON. -->
    <bean id="modelJson1" factory-bean="vfs2FileManager" factory-method="resolveFile">
        <constructor-arg value="${model_location_1}" />
    </bean>

    <!--
        The scala.util.Try with the model. This either contains the model or an exception.  When calling '.get()'
        it will either return the model on success or will throw the exception it is holding.
    -->
    <bean id="modelTry1" factory-bean="modelFactory" factory-method="fromVfs2">
        <constructor-arg ref="modelJson1" />
    </bean>

    <!--
        The actual model.  May throw an exception.  This can be done in the code if we want to handle failures
        in a specific way.
    -->
    <bean id="doubleModel1" factory-bean="modelTry1" factory-method="get" />

    <!-- *************************************************************************************************** -->
    <!--                                     CREATE SECOND MODEL HERE ...                                    -->
    <!-- *************************************************************************************************** -->
    <!-- Construct model using the fromResource interface. Probably want to use fromClasspathResource in prod. -->
    <bean id="modelTry2" factory-bean="modelFactory" factory-method="fromResource">
        <constructor-arg value="${model_location_2}" />
    </bean>

    <bean id="doubleModel2" factory-bean="modelTry2" factory-method="get" />

    <!-- *************************************************************************************************** -->
    <!--                                    CREATE LIST OF MODELS HERE ...                                   -->
    <!-- *************************************************************************************************** -->
    <bean id="models" class="java.util.ArrayList">
        <constructor-arg>
            <list>
                <ref bean="doubleModel1" />
                <ref bean="doubleModel2" />
            </list>
        </constructor-arg>
    </bean>
</beans>
