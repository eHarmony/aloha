package com.eharmony.aloha.semantics.compiled.plugin.avro

import java.io.File

import com.eharmony.aloha.audit.impl.OptionAuditor
import com.eharmony.aloha.factory.ModelFactory
import com.eharmony.aloha.reflect.{RefInfo, RefInfoOps}
import com.eharmony.aloha.semantics.compiled.CompiledSemantics
import com.eharmony.aloha.semantics.compiled.compiler.TwitterEvalCompiler
import org.apache.avro
import org.apache.avro.Protocol
import org.apache.avro.file.{DataFileReader, DataFileWriter}
import org.apache.avro.generic.{GenericData, GenericDatumReader, GenericDatumWriter, GenericRecord}
import org.apache.avro.util.Utf8
import org.apache.commons.io.IOUtils
import org.apache.commons.vfs2.VFS
import org.junit.Assert._
import org.junit.Test

import scala.collection.JavaConversions.{asJavaIterable, asScalaIterator, collectionAsScalaIterable, iterableAsScalaIterable}
import scala.concurrent.ExecutionContext.Implicits.global
import java.{util => ju}
import java.{lang => jl}

import com.eharmony.aloha.FileLocations
import com.eharmony.aloha.feature.BasicFunctions
import com.eharmony.aloha.semantics.SemanticsUdfException

/**
  * Created by ryan.
  */
class CompiledSemanticsAvroPluginTest {
  import CompiledSemanticsAvroPluginTest._


  private[this] lazy val semantics = {
    val plugin = CompiledSemanticsAvroPlugin[GenericRecord](Schemas(0), dereferenceAsOptional = true)
    // Provide a cache for the classes generated by the compiler.
    CompiledSemantics(
      TwitterEvalCompiler(
        classCacheDir = Option(FileLocations.testGeneratedClasses)
      ),
      plugin = plugin,
      imports = Seq("com.eharmony.aloha.feature.BasicFunctions._"))
  }

  private[this] lazy val semanticsNotOptDeref = {
    val plugin = CompiledSemanticsAvroPlugin[GenericRecord](Schemas(0), dereferenceAsOptional = false)
    // Provide a cache for the classes generated by the compiler.
    CompiledSemantics(
      TwitterEvalCompiler(
        //  classCacheDir = Option(FileLocations.testGeneratedClasses)
      ),
      plugin = plugin,
      imports = Seq("com.eharmony.aloha.feature.BasicFunctions._"))
  }

  @Test def testOptOptOptlist(): Unit = {
    val (missing, present) = (genRecords.head, genRecords.last)

    def optOptOptlist(r: GenericRecord): Iterable[(String, Double)] = {
      (
        for {
          _1 <- Option(r.get("opt_c1")).asInstanceOf[Option[GenericRecord]]
          _2 <- Option(_1.get("opt_c2")).asInstanceOf[Option[GenericRecord]]
          _3 <- Option(_2.get("opt_rep_str_3")).asInstanceOf[Option[java.util.List[Utf8]]]
          _4 = _3.map(_.toString)
          _5 = BasicFunctions.ind(_4)
        } yield _5
      ) getOrElse Nil
    }

    def reqReqReqlist(r: GenericRecord): Iterable[(String, Double)] = {
      val _1 = r.get("req_c1").asInstanceOf[GenericRecord]
      val _2 = _1.get("req_c2").asInstanceOf[GenericRecord]
      val _3 = _2.get("rep_str_3").asInstanceOf[java.util.List[Utf8]]
      val _4 = _3.map(_.toString)
      val _5 = BasicFunctions.ind(_4)
      _5
    }

    // Better reporting than either.right.get.
    def fn[A](e: => Either[Seq[String], A]): A = {
      val run = e // for debugging
      run.fold(m => throw new RuntimeException(m.mkString("\n")), identity)
    }

    val default = Option(Iterable.empty[(String, Double)])
    val noDefault = Option.empty[Iterable[(String, Double)]]

    lazy val oool = fn(semantics.createFunction("ind(${opt_c1.opt_c2.opt_rep_str_3})", default))
//    lazy val rrrl = fn(semantics.createFunction("ind(${req_c1.req_c2.rep_str_3})", noDefault))

    val expPresent = 1 to 3 map (i => (s"=$i", 1d))
    val expMissing = Iterable.empty

    assertEquals(expPresent, reqReqReqlist(present))

    assertEquals(expPresent, optOptOptlist(present))
    assertEquals(expMissing, optOptOptlist(missing))

    assertEquals(expPresent, oool(present))
    assertEquals(expMissing, oool(missing))

//    assertEquals(expPresent, rrrl(present))
//    assertEquals(expMissing, rrrl(missing))
  }

  @Test def testRequiredChains() {
    for {
      i <- 1 to levels
      s = "${" + (1 until i).map("req_c" + _ + ".").mkString("") + "req_int_" + i + "}"
      ff = semantics.createFunction[Int](s)
      f = ff.right.toOption.get
      j = i - 1
    } assertEquals("testRequiredChains, case " + j, 10 * j + 1, f(genRecords(j)))
  }

  // TODO: fix so that type is Seq[Int] instead of Seq[Integer]
  @Test def testRequiredChainsWithRepeated() {
    for {
      i <- 1 to levels
      s = "${" + (1 until i).map("req_c" + _ + ".").mkString + "rep_int_" + i + "}"
      f = semantics.createFunction[Seq[Int]](s).right.toOption.get
    } assertEquals("testRequiredChainsWithRepeated, case " + i, Seq.range(0, numRepeats).map(_ + 10 * (i - 1) + 2), f(genRecords(i)))
  }

  @Test def test_O() {
    val missing = Int.MinValue
    val s = "${opt_int_1}"
    val f = semantics.createFunction[Int](s, Option(missing)).right.toOption.get
    assertEquals(0, f(genRecords.last))
    assertEquals(missing, f(genRecords.head))
  }

  @Test def testStringEscaping() {
    val s = "${req_str_1} == \"" + strVal + "\""
    val f = semantics.createFunction[Boolean](s).right.get
    val v = f(genRecords.head)
    assertTrue("in testStringEscaping...", v)
  }

  /** Construct a ''Map[Int, Float](0 -> 0, 10 -> 0.1, ..., 50 -> 0.5)'',  Then use the value extracted from the
    * proto as a lookup into the map.
    */
  @Test def test_map() {
    // The else here makes the final generated function a non-Optional function.  Whether that non-optional is
    // optionally applied is up to the existence of ${opt_c1.opt_c2.opt_c3.opt_int_4}.  This is why we supply a
    // default to the createFunction function.
    val s = "0.to(50, 10).map(i => (i, i / 100f)).toMap.getOrElse(${opt_c1.opt_c2.opt_c3.opt_int_4}, Float.NegativeInfinity)"

    // Only here for readability.  Want to show that applying f gives 1/100 of this value.
    val expC4 = 30

    val actC4 = for {
      c1 <- genRecords.last.get("opt_c1").asGR
      c2 <- c1.get("opt_c2").asGR
      c3 <- c2.get("opt_c3").asGR
      c4 <- Option(c3.get("opt_int_4")) collect { case i: Integer => i.intValue() }
    } yield c4

    assertEquals(expC4, actC4.get)

    val f = semantics.createFunction[Float](s, Option(Float.NaN)).right.toOption.get
    assertEquals(expC4 / 100f, f(genRecords.last), 1.0e-5)
  }

  /**
    * '''NOTE''': The output type of the function is Seq[Int].  This is because there is no casting of the value type
    * AND implicit wrapping of container class.  This differs from the protocol buffer implementation.
    */
  @Test def test_L() {
    val s = "${rep_int_1}"
    val f = semantics.createFunction[Seq[Int]](s).right.toOption.get
    assertEquals(Seq(2, 3), f(genRecords.last))
  }

  /** An optional list of an optional field should map to a list of options.
    */
  @Test def test_OLO() {
    val testCase = genRecords(4)

    val exp = (for {
      c1 <- testCase.get("opt_c1").asGR
      c2 <- Option(c1.get("rep_c2").asInstanceOf[java.lang.Iterable[GenericRecord]])
    } yield c2.toSeq.map(v => Option(v.get("opt_int_3")).asInstanceOf[Option[Int]])).get

    // Because opt_int_3 is an 'optional int32' in the proto definition, and rep_c2 is repeated
    // the resulting type is a sequence of Option of Int.
    val s = "${opt_c1.rep_c2.opt_int_3}"
    val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get

    val act = f(testCase)
    assertEquals(exp, act)
  }

  @Test def test_OROLOOR() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4.opt_c5.opt_c6.req_int_7}"
    val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get
    assertEquals(Seq.fill(2)(Some(61)), f(genRecords.last))
  }

  @Test def test_OROLOOO() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4.opt_c5.opt_c6.opt_int_7}"
    val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get
    assertEquals(Seq.fill(2)(Some(60)), f(genRecords.last))
  }

  @Test def test_OROL() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4}"
    val ff = semantics.createFunction[Seq[GenericRecord]](s)
    ff.left.foreach("test_OROL: " + _)
    val f = ff.right.toOption.get

    val exp = (for {
      last <- Option(genRecords.last)
      c1 <- last.get("opt_c1").asGR
      c2 <- c1.get("req_c2").asGR
      c3 <- c2.get("opt_c3").asGR
      c4 <- Option(c3.get("rep_c4")).asInstanceOf[Option[java.lang.Iterable[GenericRecord]]].map(it => it.toSeq)
    } yield c4).get


    assertEquals(exp, f(genRecords.last))
  }

  /**
    * Test that an optional list is compiled
    */
  @Test def testOptionalListOfReq(): Unit = {
    val sum = semantics.createFunction[Int]("${orep_int_1}.sum").right.get
    val s = sum(genRecords.last)
    assertEquals(0, s)
  }

  /**
    * Test that an optional list is compiled
    */
  @Test def testOptionalListOfOpt(): Unit = {
    val sumOpt = semantics.createFunction[Int]("${orep_oint_1}.flatten.sum")
    val sum  = sumOpt.right.get
    val s = sum(genRecords.last)
    assertEquals(0, s)
  }

  private[this] def testType[A: RefInfo](field: String, value: Any): Unit = {
    val v =
      if (value.isInstanceOf[String])
        s""""${value.toString}""""
      else value.toString

    val t = RefInfoOps.toString[A]
    val code = "${" + field + "}.isInstanceOf[" + t + "] && ${" + field + "} == " + v
    val check = semantics.createFunction[Boolean](code, Some(false)).right.get

    assertTrue(s"Something is wrong with $t functions.  code: $code", check(genRecords.last))
  }

  @Test def testOptionalBoolean(): Unit = testType[Boolean]("ob", boolVal)
  @Test def testOptionalString(): Unit = testType[String]("os", strVal)
  @Test def testOptionalInt(): Unit = testType[Int]("oi", intVal)
  @Test def testOptionalLong(): Unit = testType[Long]("ol", longVal)
  @Test def testOptionalFloat(): Unit = testType[Float]("of", floatVal)
  @Test def testOptionalDouble(): Unit = testType[Double]("od", doubleVal)

  @Test def testDereferenceReqAsOpt(): Unit = {
    val x = new GenericData.Record(genRecords.last, true)
    x.put("orep_int_1", jList(jl.Integer.valueOf(1), jl.Integer.valueOf(2)))
    val spec = "${orep_int_1[0]} == 1 && ${orep_int_1[1]} == 2"
    val checkOpt = semantics.createFunction[Boolean](spec, Some(false))
    val check = checkOpt.right.get
    val res = check(x)
    assertTrue(res)
  }

  @Test def testDereferenceOptAsOptDefault(): Unit = {
    val x = new GenericData.Record(genRecords.last, true)
    x.put("orep_oint_1", jList(jl.Integer.valueOf(1), null))
    val spec = "if (${orep_oint_1[0]} == 1 && ${orep_oint_1[1]:-2} == 2) 1 else 2"
    val checkOpt = semantics.createFunction[Int](spec, Some(3))
    val check = checkOpt.right.get
    val res = check(x)
    assertEquals(1, res)
  }

  @Test def testDereferenceOptAsOptNoDefault(): Unit = {
    val x = new GenericData.Record(genRecords.last, true)
    x.put("orep_oint_1", jList(jl.Integer.valueOf(1), null))
    val spec = "if (${orep_oint_1[0]} == 1 && ${orep_oint_1[1]} == 2) 1 else 2"
    val checkOpt = semantics.createFunction[Int](spec, Some(3))
    val check = checkOpt.right.get
    val res = check(x)
    assertEquals(3, res)
  }

  @Test def testDereferenceReqAsReq(): Unit = {
    val x = new GenericData.Record(genRecords.last, true)
    x.put("orep_int_1", jList(jl.Integer.valueOf(1), jl.Integer.valueOf(2)))
    val spec = "${orep_int_1[0]} == 1"
    val checkOpt = semantics.createFunction[Boolean](spec, Some(false))
    val check = checkOpt.right.get
    val res = check(x)
    assertTrue(res)
  }

  @Test def testDereferenceReqAsReqThenReqFlagFalse(): Unit = {
    val varSpec = "rep_c1[0].req_c2.req_int_3"
    val spec = "${"+varSpec+"}"
    val fOpt = semanticsNotOptDeref.createFunction[Int](spec, None)
    val f = fOpt.right.get
    assertEquals(21, f(genRecords.last))

    try {
      f(genRecords.head)
    }
    catch {
      case SemanticsUdfException(_, _, accessorsMissingOutput, accessorsInErr, cause, _) =>
        assertEquals(Seq(varSpec), accessorsInErr)
        assertTrue(accessorsMissingOutput.isEmpty)
        assertTrue(cause.isInstanceOf[IndexOutOfBoundsException])
        assertEquals("Index 0 out of bounds.", cause.getMessage)
      case t: Throwable => throw t
    }
  }

  /**
    * First cast needs to add Option before list.
    *
    * Change
    *
    * {{{
    * (_0: GenericRecord) =>
    *   Option(_0.get("rep_c1")).
    *   asInstanceOf[java.util.List[GenericRecord]].
    *   flatMap{ case l if l.size > 0 => Option(l.get(0)); case _ => None }.
    *   map(_1 =>
    *     _1.get("req_c2").
    *     asInstanceOf[GenericRecord].
    *     get("req_int_3").
    *     asInstanceOf[Int]
    *   )
    * }}}
    *
    * to
    *
    * {{{
    * (_0: GenericRecord) =>
    *   Option(_0.get("rep_c1")).
    *   asInstanceOf[Option[java.util.List[GenericRecord]]].
    *   flatMap{ case l if l.size > 0 => Option(l.get(0)); case _ => None }.
    *   map(_1 =>
    *     _1.get("req_c2").
    *     asInstanceOf[GenericRecord].
    *     get("req_int_3").
    *     asInstanceOf[Int]
    *   )
    * }}}
    */
  @Test def testDereferenceReqAsReqThenReqFlagTrue(): Unit = {
    val varSpec = "rep_c1[0].req_c2.req_int_3"
    val spec = "${"+varSpec+"}"
    val fOpt = semantics.createFunction[Int](spec, Some(Int.MinValue))
    val f = fOpt.right.get
    assertEquals(21, f(genRecords.last))
    assertEquals(Int.MinValue, f(genRecords.head))
  }


  // This stuff that follows isn't really necessary.

  private[this] def bagOfWordsRecord = {
    val r = new GenericData.Record(genRecords.last, true)
    r.put("req_str_1", new Utf8("handsome smart stubborn"))
    r
  }

  @Test def test_BagOfWords1() {
    val s = """${req_str_1}.split("\\W+").zip(Stream continually 1.0)"""
    val f = semantics.createFunction[Iterable[(String, Double)]](s).right.toOption.get

    val a = f(bagOfWordsRecord).toSet
    assertEquals(Set(("handsome", 1.0), ("smart", 1.0), ("stubborn", 1.0)), a)
  }

  @Test def test_BagOfWords2() {
    val f = ModelFactory.defaultFactory(semantics, OptionAuditor[Double]())

    val m = f.fromString(
      """
        |{
        |  "modelType": "Regression",
        |  "modelId": { "id": 0, "name": "" },
        |  "features" : {
        |    "my_attributes": "${req_str_1}.split(\"\\\\W+\").map(v => (s\"=$v\", 1.0))"
        |  },
        |  "weights": {
        |    "my_attributes=handsome": 1,
        |    "my_attributes=smart": 2,
        |    "my_attributes=stubborn": 4
        |  }
        |}
      """.stripMargin).get

    val v = m(bagOfWordsRecord)
    assertEquals(7d, v.get, 0)
  }

  private[this] def jList[A](as: A*): ju.List[A] = {
    val lst = new ju.ArrayList[A](as.size)
    as.foreach(lst.add)
    lst
  }
}

private[avro] object CompiledSemanticsAvroPluginTest {
  implicit class ToGenericRecord(val r: Any) extends AnyVal {
    def asGR: Option[GenericRecord] = Option(r) collect { case r: GenericRecord => r }
  }

  lazy val Schemas: Vector[avro.Schema] = {
    val is = VFS.getManager.resolveFile("res:avro/test.avpr").getContent.getInputStream
    try {
      val protocol = Protocol.parse(is)
      val schemas = protocol.getTypes.toVector.reverse
      schemas
    }
    finally {
      IOUtils.closeQuietly(is)
    }
  }

  /**
    * A serialization round trip ensures that everything adheres to the top-level schema.
    */
  lazy val genRecords = serializationRoundTrip((0 to levels).map(testGenRecord), Schemas(0))

  val numRepeats = 2
  val levels = 7

  val boolVal = true
  val strVal = "test"
  val intVal = 3
  val longVal = 4L
  val floatVal = 5f
  val doubleVal = 6d

  def repeatedSeq(level: Int) = (0 until numRepeats).map(2 + level * 10 + _)
  def optVal(level: Int) = Option(10 * level)

  /** Get a testGenRecord filled in for user in tests.
    * @param m 0 <= m <= levels.  The number of levels to fill in.
    * @return
    */
  def testGenRecord(m: Int) = {
    require(0 <= m && m <= levels, "Expected 0 <= m <= " + levels + ". Found " + m)
    val o = (0 until m).map(optVal) ++ Seq.fill(levels - m)(None)
    val s = (0 until m).map(repeatedSeq) ++ Seq.fill(levels - m)(Nil)
    val b0 = fillClassInts(0, o(0),  1, s(0):_*)
    b0.put("req_str_1", strVal)

    val b1 = fillClassInts(1, o(1), 11, s(1):_*)
    val b2 = fillClassInts(2, o(2), 21, s(2):_*)
    val b3 = fillClassInts(3, o(3), 31, s(3):_*)
    val b4 = fillClassInts(4, o(4), 41, s(4):_*)
    val b5 = fillClassInts(5, o(5), 51, s(5):_*)
    val b6 = fillClassInts(6, o(6), 61, s(6):_*)

    // Put the repeated strings in Class3.
    b2.put("rep_str_3", asJavaIterable(1 to 3 map (_.toString)))
    b2.put("opt_rep_str_3", asJavaIterable(1 to 3 map (_.toString)))

    if (6 < m) { b5.put("opt_c6", b6); b5.put("rep_c6", asJavaIterable(Seq.fill(s(5).size)(b6))) } else b5.put("rep_c6", asJavaIterable(Iterable()))
    b5.put("req_c6", b6)
    if (5 < m) { b4.put("opt_c5", b5); b4.put("rep_c5", asJavaIterable(Seq.fill(s(4).size)(b5))) } else b4.put("rep_c5", asJavaIterable(Iterable()))
    b4.put("req_c5", b5)
    if (4 < m) { b3.put("opt_c4", b4); b3.put("rep_c4", asJavaIterable(Seq.fill(s(3).size)(b4))) } else b3.put("rep_c4", asJavaIterable(Iterable()))
    b3.put("req_c4", b4)
    if (3 < m) { b2.put("opt_c3", b3); b2.put("rep_c3", asJavaIterable(Seq.fill(s(2).size)(b3))) } else b2.put("rep_c3", asJavaIterable(Iterable()))
    b2.put("req_c3", b3)
    if (2 < m) { b1.put("opt_c2", b2); b1.put("rep_c2", asJavaIterable(Seq.fill(s(1).size)(b2))) } else b1.put("rep_c2", asJavaIterable(Iterable()))
    b1.put("req_c2", b2)
    if (1 < m) { b0.put("opt_c1", b1); b0.put("rep_c1", asJavaIterable(Seq.fill(s(0).size)(b1))) } else b0.put("rep_c1", asJavaIterable(Iterable()))
    b0.put("req_c1", b1)

    b0.put("ob", boolVal)
    b0.put("os", strVal)
    b0.put("oi", intVal)
    b0.put("ol", longVal)
    b0.put("of", floatVal)
    b0.put("od", doubleVal)

    b0
  }

  def fillClassInts(level: Int, o: Option[Int], r: Int, l: Int*) = {
    val id = level + 1
    val schema = Schemas(level)
    val rec = new GenericData.Record(schema)
    o foreach { rec.put(s"opt_int_$id", _) }
    rec.put(s"req_int_$id", r)
    rec.put(s"rep_int_$id", asJavaIterable(l))
    rec
  }

  def serializationRoundTrip(records: Seq[GenericRecord], schema: avro.Schema): Vector[GenericData.Record] = {
    val datumWriter = new GenericDatumWriter[GenericRecord](schema)
    val f = File.createTempFile("avrotest", ".dat")
    f.deleteOnExit()

    // Serialize
    val fileWriter = new DataFileWriter(datumWriter)
    fileWriter.create(schema, f)
    records.foreach(fileWriter.append)
    fileWriter.close()

    // Deserialize
    val datumReader = new GenericDatumReader[GenericRecord](schema)
    val dataFileReader = new DataFileReader(f, datumReader)
    val deserializedRecords = dataFileReader.iterator().toVector
    dataFileReader.close()

    // Unsafe cast but it is true.
    deserializedRecords.asInstanceOf[Vector[GenericData.Record]]
  }
}
