package com.eharmony.aloha.semantics.compiled.plugin.avro

import java.io.File
import java.{lang => jl, util => ju}

import com.eharmony.aloha.FileLocations
import com.eharmony.aloha.audit.impl.OptionAuditor
import com.eharmony.aloha.factory.ModelFactory
import com.eharmony.aloha.reflect.{RefInfo, RefInfoOps}
import com.eharmony.aloha.semantics.SemanticsUdfException
import com.eharmony.aloha.semantics.compiled.CompiledSemantics
import com.eharmony.aloha.semantics.compiled.compiler.TwitterEvalCompiler
import org.apache.avro
import org.apache.avro.Protocol
import org.apache.avro.file.{DataFileReader, DataFileWriter}
import org.apache.avro.generic.{GenericData, GenericDatumReader, GenericDatumWriter, GenericRecord}
import org.apache.avro.util.Utf8
import org.apache.commons.io.IOUtils
import org.apache.commons.vfs2.VFS
import org.junit.Assert._
import org.junit.Test

import scala.collection.JavaConversions.{asJavaIterable, asScalaIterator, collectionAsScalaIterable, iterableAsScalaIterable}
import scala.collection.JavaConverters.seqAsJavaListConverter
import scala.concurrent.ExecutionContext.Implicits.global

/**
  * Created by ryan.
  */
class CompiledSemanticsAvroPluginTest {
  import CompiledSemanticsAvroPluginTest._


  private[this] lazy val semantics = {
    val plugin = CompiledSemanticsAvroPlugin[GenericRecord](Schemas(0), dereferenceAsOptional = true)
    // Provide a cache for the classes generated by the compiler.
    CompiledSemantics(
      TwitterEvalCompiler(
        classCacheDir = Option(FileLocations.testGeneratedClasses)
      ),
      plugin = plugin,
      imports = Seq("com.eharmony.aloha.feature.BasicFunctions._"))
  }

  private[this] lazy val semanticsNotOptDeref = {
    val plugin = CompiledSemanticsAvroPlugin[GenericRecord](Schemas(0), dereferenceAsOptional = false)
    // Provide a cache for the classes generated by the compiler.
    CompiledSemantics(
      TwitterEvalCompiler(
        //  classCacheDir = Option(FileLocations.testGeneratedClasses)
      ),
      plugin = plugin,
      imports = Seq("com.eharmony.aloha.feature.BasicFunctions._"))
  }

  @Test def testRepeatedCases(): Unit = {
    val specs = Seq(
      "${opt_c1.opt_c2.rep_c3} flatMap (x => ind(x.toString))",
      "${opt_c1.opt_c2.rep_c3.opt_c4.req_int_5}.flatten flatMap ind",
      "${opt_c1.opt_c2.rep_c3.req_int_4} flatMap ind",

      "${opt_c1.opt_c2.opt_rep_c3.opt_c4.opt_int_5}.flatten flatMap ind"
    )

    specs.zipWithIndex foreach { case (s, i) =>
      val f = semantics.createFunction(s, Option(Iterable.empty[(String, Double)]))
      f.left.foreach(msgs => fail((s"Failure in case $i ($s):" +: msgs.map(m => s"\t$m")).mkString("\n")))
    }
  }


  // TODO: This should pass.  Need to fix bug and then remove the ignore.
  @Test def testRepeatedInMiddleOfVarPath(): Unit = {
    val specs = Seq(
      // These have optional values after the repeated element so the variable has type:
      // ${...}: Seq[Option[Int]]
      "${opt_c1.opt_c2.opt_rep_c3.opt_c4.opt_int_5}.flatten flatMap ind",
      "${opt_c1.opt_c2.opt_rep_c3.opt_c4.req_int_5}.flatten flatMap ind",

      // Optional values.
      "${opt_c1.opt_c2.rep_c3.req_c4.req_int_5} flatMap ind",
      "${req_c1.opt_c2.rep_c3.req_c4.req_int_5} flatMap ind",
      "${opt_c1.req_c2.rep_c3.req_c4.req_int_5} flatMap ind",
      "${req_c1.req_c2.rep_c3.req_c4.req_int_5} flatMap ind",

      "${opt_c1.opt_c2.opt_rep_c3.req_c4.req_int_5} flatMap ind",
      "${req_c1.opt_c2.opt_rep_c3.req_c4.req_int_5} flatMap ind",
      "${opt_c1.req_c2.opt_rep_c3.req_c4.req_int_5} flatMap ind",
      "${req_c1.req_c2.opt_rep_c3.req_c4.req_int_5} flatMap ind"
    )

    val fns = specs map (s =>
      semantics.createFunction(s, Option(Iterable.empty[(String, Double)]))
               .fold(errs => throw new Exception(s"for spec '$s': ${errs.mkString("\n")}"), f => f)
    )

    val res = fns.map { f => f(genRecords.last)}

    val expected = Seq.fill(2)(Nil) ++
                   Seq.fill(4)(Seq.fill(2)(("=41",1d))) ++
                   Seq.fill(4)(Nil)

    assertEquals(expected, res)
  }

  @Test def testDereferencingOOOl(): Unit = {
    val f = semantics.createFunction[String]("${opt_c1.opt_c2.opt_rep_str_3[0]}", Some("no string found"))
      .fold(m => throw new Exception(m.mkString("\n")), identity)
    val x = genRecords.last
    val y = f(x)
    assertEquals("1", y)
  }

  @Test def testDereferencingOORl(): Unit = {
    val f = semantics.createFunction[String]("${opt_c1.opt_c2.rep_str_3[0]}", Some("no string found"))
      .fold(m => throw new Exception(m.mkString("\n")), identity)
    val x = genRecords.last
    val y = f(x)
    assertEquals("1", y)
  }

  @Test def testDereferencingOOOlR(): Unit = {
    val whenMissing = Int.MinValue
    val f = semantics.createFunction[Int]("${opt_c1.opt_c2.opt_rep_c3[0].req_int_4}", Some(whenMissing))
      .fold(m => throw new Exception(m.mkString("\n")), identity)
    val x = genRecords.last
    val y = f(x)
    assertEquals(whenMissing, y)
  }

  @Test def testDereferencingOOOlO(): Unit = {
    val expected = 523

    val x = {
      val msg = new GenericData.Record(Schemas(0))
      msg.put("opt_c1", {
        val c1 = new GenericData.Record(Schemas(1))
        c1.put("opt_c2", {
          val c2 = new GenericData.Record(Schemas(2))
          c2.put("opt_rep_c3", {
            val c3 = new GenericData.Record(Schemas(3))
            c3.put("opt_int_4", expected)
            Seq(c3).asJava
          })
          c2
        })
        c1
      })
      msg
    }

    val whenMissing = Int.MinValue
    val f = semantics.createFunction[Int]("${opt_c1.opt_c2.opt_rep_c3[0].opt_int_4}", Some(whenMissing))
      .fold(m => throw new Exception(m.mkString("\n")), identity)
    val y = f(x)
    assertEquals(expected, y)
  }


  @Test def testDereferencingOORlR(): Unit = {
    val whenMissing = Int.MinValue
    val f = semantics.createFunction[Int]("${opt_c1.opt_c2.rep_c3[0].req_int_4}", Some(whenMissing))
      .fold(m => throw new Exception(m.mkString("\n")), identity)
    val x = genRecords.last
    val y = f(x)
    assertEquals(31, y)
  }

  @Test def testDereferencingOORlO(): Unit = {
    val expected = 523

    val x: GenericRecord = {
      val msg = new GenericData.Record(Schemas(0))
      msg.put("opt_c1", {
        val c1 = new GenericData.Record(Schemas(1))
        c1.put("opt_c2", {
          val c2 = new GenericData.Record(Schemas(2))
          c2.put("opt_rep_c3", {
            val c3 = new GenericData.Record(Schemas(3))
            c3.put("opt_int_4", expected)
            Seq(c3).asJava
          })
          c2
        })
        c1
      })
      msg
    }

    val whenMissing = Int.MinValue

    val f = semantics.createFunction[Int]("${opt_c1.opt_c2.opt_rep_c3[0].opt_int_4}", Some(whenMissing))
      .fold(m => throw new Exception(m.mkString("\n")), identity)
    val y = f(x)
    assertEquals(expected, y)
  }

  @Test def testRepeatedAtEndOfVarPath(): Unit = {
    val specs = Seq(
      "ind(${opt_c1.opt_c2.opt_rep_str_3})",
      "ind(${req_c1.opt_c2.opt_rep_str_3})",
      "ind(${opt_c1.req_c2.opt_rep_str_3})",
      "ind(${req_c1.req_c2.opt_rep_str_3})",

      "ind(${opt_c1.opt_c2.rep_str_3})",
      "ind(${req_c1.opt_c2.rep_str_3})",
      "ind(${opt_c1.req_c2.rep_str_3})",
      "ind(${req_c1.req_c2.rep_str_3})",

      "${opt_c1.opt_c2.opt_rep_int_3} flatMap ind",
      "${req_c1.opt_c2.opt_rep_int_3} flatMap ind",
      "${opt_c1.req_c2.opt_rep_int_3} flatMap ind",
      "${req_c1.req_c2.opt_rep_int_3} flatMap ind",

      "${opt_c1.opt_c2.rep_int_3} flatMap ind",
      "${req_c1.opt_c2.rep_int_3} flatMap ind",
      "${opt_c1.req_c2.rep_int_3} flatMap ind",
      "${req_c1.req_c2.rep_int_3} flatMap ind"
    )

    // Compile and run function.
    val results = specs map { s =>
      semantics.createFunction(s, Option(Iterable.empty[(String, Double)])) match {
        case Left(errs) => throw new Exception(s"for spec '$s': ${errs.mkString("\n")}")
        case Right(f) => f(genRecords.last)
      }
    }

    val expected =
      Seq.fill(8)((1 to 3).map(i => (s"=$i", 1d))) ++
      Seq.fill(4)(Nil) ++
      Seq.fill(4)((22 to 23).map(i => (s"=$i", 1d)))

    assertEquals(expected, results)
  }

  @Test def testRequiredChains() {
    for {
      i <- 1 to levels
      s = "${" + (1 until i).map("req_c" + _ + ".").mkString("") + "req_int_" + i + "}"
      ff = semantics.createFunction[Int](s)
      f = ff.right.toOption.get
      j = i - 1
    } assertEquals("testRequiredChains, case " + j, 10 * j + 1, f(genRecords(j)))
  }

  // TODO: fix so that type is Seq[Int] instead of Seq[Integer]
  @Test def testRequiredChainsWithRepeated() {
    for {
      i <- 1 to levels
      s = "${" + (1 until i).map("req_c" + _ + ".").mkString + "rep_int_" + i + "}"
      f = semantics.createFunction[Seq[Int]](s).right.toOption.get
    } assertEquals("testRequiredChainsWithRepeated, case " + i, Seq.range(0, numRepeats).map(_ + 10 * (i - 1) + 2), f(genRecords(i)))
  }

  @Test def test_O() {
    val missing = Int.MinValue
    val s = "${opt_int_1}"
    val f = semantics.createFunction[Int](s, Option(missing)).right.toOption.get
    assertEquals(0, f(genRecords.last))
    assertEquals(missing, f(genRecords.head))
  }

  @Test def testStringEscaping() {
    val s = "${req_str_1} == \"" + strVal + "\""
    val f = semantics.createFunction[Boolean](s).right.get
    val v = f(genRecords.head)
    assertTrue("in testStringEscaping...", v)
  }

  /** Construct a ''Map[Int, Float](0 -> 0, 10 -> 0.1, ..., 50 -> 0.5)'',  Then use the value extracted from the
    * proto as a lookup into the map.
    */
  @Test def test_map() {
    // The else here makes the final generated function a non-Optional function.  Whether that non-optional is
    // optionally applied is up to the existence of ${opt_c1.opt_c2.opt_c3.opt_int_4}.  This is why we supply a
    // default to the createFunction function.
    val s = "0.to(50, 10).map(i => (i, i / 100f)).toMap.getOrElse(${opt_c1.opt_c2.opt_c3.opt_int_4}, Float.NegativeInfinity)"

    // Only here for readability.  Want to show that applying f gives 1/100 of this value.
    val expC4 = 30

    val actC4 = for {
      c1 <- genRecords.last.get("opt_c1").asGR
      c2 <- c1.get("opt_c2").asGR
      c3 <- c2.get("opt_c3").asGR
      c4 <- Option(c3.get("opt_int_4")) collect { case i: Integer => i.intValue() }
    } yield c4

    assertEquals(expC4, actC4.get)

    val f = semantics.createFunction[Float](s, Option(Float.NaN)).right.toOption.get
    assertEquals(expC4 / 100f, f(genRecords.last), 1.0e-5)
  }

  /**
    * '''NOTE''': The output type of the function is Seq[Int].  This is because there is no casting of the value type
    * AND implicit wrapping of container class.  This differs from the protocol buffer implementation.
    */
  @Test def test_L() {
    val s = "${rep_int_1}"
    val f = semantics.createFunction[Seq[Int]](s).right.toOption.get
    assertEquals(Seq(2, 3), f(genRecords.last))
  }

  /** An optional list of an optional field should map to a list of options.
    */
  @Test def test_OLO() {
    val testCase = genRecords(4)

    val exp = (for {
      c1 <- testCase.get("opt_c1").asGR
      c2 <- Option(c1.get("rep_c2").asInstanceOf[java.lang.Iterable[GenericRecord]])
    } yield c2.toSeq.map(v => Option(v.get("opt_int_3")).asInstanceOf[Option[Int]])).get

    // Because opt_int_3 is an 'optional int32' in the proto definition, and rep_c2 is repeated
    // the resulting type is a sequence of Option of Int.
    val s = "${opt_c1.rep_c2.opt_int_3}"
    val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get

    val act = f(testCase)
    assertEquals(exp, act)
  }

  @Test def test_OROLOOR() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4.opt_c5.opt_c6.req_int_7}"
    val fn = semantics.createFunction[Seq[Option[Int]]](s)
    val f = fn.left.map(m => throw new Exception(m.mkString("\n"))).right.toOption.get
    assertEquals(Seq.fill(2)(Some(61)), f(genRecords.last))
  }

  @Test def test_OROLOOO() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4.opt_c5.opt_c6.opt_int_7}"
    val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get
    assertEquals(Seq.fill(2)(Some(60)), f(genRecords.last))
  }

  @Test def test_OROL() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4}"
    val ff = semantics.createFunction[Seq[GenericRecord]](s)
    ff.left.foreach("test_OROL: " + _)
    val f = ff.right.toOption.get

    val exp = (for {
      last <- Option(genRecords.last)
      c1 <- last.get("opt_c1").asGR
      c2 <- c1.get("req_c2").asGR
      c3 <- c2.get("opt_c3").asGR
      c4 <- Option(c3.get("rep_c4")).asInstanceOf[Option[java.lang.Iterable[GenericRecord]]].map(it => it.toSeq)
    } yield c4).get


    assertEquals(exp, f(genRecords.last))
  }

  /**
    * Test that an optional list is compiled
    */
  @Test def testOptionalListOfReq(): Unit = {
    val sum = semantics.createFunction[Int]("${orep_int_1}.sum").right.get
    val s = sum(genRecords.last)
    assertEquals(0, s)
  }

  /**
    * Test that an optional list is compiled
    */
  @Test def testOptionalListOfOpt(): Unit = {
    val sum = semantics.createFunction[Int]("${orep_oint_1}.flatten.sum").right.get
    val s = sum(genRecords.last)
    assertEquals(0, s)
  }

  @Test def testOptionalListOfString(): Unit = {
    val sum = semantics.createFunction[Int]("${orep_str_1}.foldLeft(0)(_ + _.size)").right.get
    val s = sum(genRecords.last)
    assertEquals(0, s)
  }

  @Test def testOptionalListOfInt(): Unit = {
    val sum = semantics.createFunction[Int]("${orep_int_1}.foldLeft(0)(_ + _.size)").right.get
    val s = sum(genRecords.last)
    assertEquals(0, s)
  }

  private[this] def testType[A: RefInfo](field: String, value: Any): Unit = {
    val v =
      if (value.isInstanceOf[String])
        s""""${value.toString}""""
      else value.toString

    val t = RefInfoOps.toString[A]
    val code = "${" + field + "}.isInstanceOf[" + t + "] && ${" + field + "} == " + v
    val check = semantics.createFunction[Boolean](code, Some(false)).right.get

    assertTrue(s"Something is wrong with $t functions.  code: $code", check(genRecords.last))
  }

  @Test def testOptionalBoolean(): Unit = testType[Boolean]("ob", boolVal)
  @Test def testOptionalString(): Unit = testType[String]("os", strVal)
  @Test def testOptionalInt(): Unit = testType[Int]("oi", intVal)
  @Test def testOptionalLong(): Unit = testType[Long]("ol", longVal)
  @Test def testOptionalFloat(): Unit = testType[Float]("of", floatVal)
  @Test def testOptionalDouble(): Unit = testType[Double]("od", doubleVal)

  @Test def testDereferenceReqAsOpt(): Unit = {
    val x = new GenericData.Record(genRecords.last, true)
    x.put("orep_int_1", jList(jl.Integer.valueOf(1), jl.Integer.valueOf(2)))
    val spec = "${orep_int_1[0]} == 1 && ${orep_int_1[1]} == 2"
    val checkOpt = semantics.createFunction[Boolean](spec, Some(false))
    val check = checkOpt.right.get
    val res = check(x)
    assertTrue(res)
  }

  @Test def testDereferenceOptAsOptDefault(): Unit = {
    val x = new GenericData.Record(genRecords.last, true)
    x.put("orep_oint_1", jList(jl.Integer.valueOf(1), null))
    val spec = "if (${orep_oint_1[0]} == 1 && ${orep_oint_1[1]:-2} == 2) 1 else 2"
    val checkOpt = semantics.createFunction[Int](spec, Some(3))
    val check = checkOpt.right.get
    val res = check(x)
    assertEquals(1, res)
  }

  @Test def testDereferenceOptAsOptNoDefault(): Unit = {
    val x = new GenericData.Record(genRecords.last, true)
    x.put("orep_oint_1", jList(jl.Integer.valueOf(1), null))
    val spec = "if (${orep_oint_1[0]} == 1 && ${orep_oint_1[1]} == 2) 1 else 2"
    val checkOpt = semantics.createFunction[Int](spec, Some(3))
    val check = checkOpt.right.get
    val res = check(x)
    assertEquals(3, res)
  }

  @Test def testDereferenceReqAsReq(): Unit = {
    val x = new GenericData.Record(genRecords.last, true)
    x.put("orep_int_1", jList(jl.Integer.valueOf(1), jl.Integer.valueOf(2)))
    val spec = "${orep_int_1[0]} == 1"
    val checkOpt = semantics.createFunction[Boolean](spec, Some(false))
    val check = checkOpt.right.get
    val res = check(x)
    assertTrue(res)
  }

  @Test def testDereferenceReqAsReqThenReqFlagFalse(): Unit = {
    val varSpec = "rep_c1[0].req_c2.req_int_3"
    val spec = "${"+varSpec+"}"
    val fOpt = semanticsNotOptDeref.createFunction[Int](spec, None)
    val f = fOpt.right.get
    assertEquals(21, f(genRecords.last))

    try {
      f(genRecords.head)
    }
    catch {
      case SemanticsUdfException(_, _, accessorsMissingOutput, accessorsInErr, cause, _) =>
        assertEquals(Seq(varSpec), accessorsInErr)
        assertTrue(accessorsMissingOutput.isEmpty)
        assertTrue(cause.isInstanceOf[IndexOutOfBoundsException])
        assertEquals("Index 0 out of bounds.", cause.getMessage)
      case t: Throwable => throw t
    }
  }

  /**
    * First cast needs to add Option before list.
    *
    * Change
    *
    * {{{
    * (_0: GenericRecord) =>
    *   Option(_0.get("rep_c1")).
    *   asInstanceOf[java.util.List[GenericRecord]].
    *   flatMap{ case l if l.size > 0 => Option(l.get(0)); case _ => None }.
    *   map(_1 =>
    *     _1.get("req_c2").
    *     asInstanceOf[GenericRecord].
    *     get("req_int_3").
    *     asInstanceOf[Int]
    *   )
    * }}}
    *
    * to
    *
    * {{{
    * (_0: GenericRecord) =>
    *   Option(_0.get("rep_c1")).
    *   asInstanceOf[Option[java.util.List[GenericRecord]]].
    *   flatMap{ case l if l.size > 0 => Option(l.get(0)); case _ => None }.
    *   map(_1 =>
    *     _1.get("req_c2").
    *     asInstanceOf[GenericRecord].
    *     get("req_int_3").
    *     asInstanceOf[Int]
    *   )
    * }}}
    */
  @Test def testDereferenceReqAsReqThenReqFlagTrue(): Unit = {
    val varSpec = "rep_c1[0].req_c2.req_int_3"
    val spec = "${"+varSpec+"}"
    val fOpt = semantics.createFunction[Int](spec, Some(Int.MinValue))
    val f = fOpt.right.get
    assertEquals(21, f(genRecords.last))
    assertEquals(Int.MinValue, f(genRecords.head))
  }


  // This stuff that follows isn't really necessary.

  private[this] def bagOfWordsRecord = {
    val r = new GenericData.Record(genRecords.last, true)
    r.put("req_str_1", new Utf8("handsome smart stubborn"))
    r
  }

  @Test def test_BagOfWords1() {
    val s = """${req_str_1}.split("\\W+").zip(Stream continually 1.0)"""
    val f = semantics.createFunction[Iterable[(String, Double)]](s).right.toOption.get

    val a = f(bagOfWordsRecord).toSet
    assertEquals(Set(("handsome", 1.0), ("smart", 1.0), ("stubborn", 1.0)), a)
  }

  @Test def test_BagOfWords2() {
    val f = ModelFactory.defaultFactory(semantics, OptionAuditor[Double]())

    val m = f.fromString(
      """
        |{
        |  "modelType": "Regression",
        |  "modelId": { "id": 0, "name": "" },
        |  "features" : {
        |    "my_attributes": "${req_str_1}.split(\"\\\\W+\").map(v => (s\"=$v\", 1.0))"
        |  },
        |  "weights": {
        |    "my_attributes=handsome": 1,
        |    "my_attributes=smart": 2,
        |    "my_attributes=stubborn": 4
        |  }
        |}
      """.stripMargin).get

    val v = m(bagOfWordsRecord)
    assertEquals(7d, v.get, 0)
  }

  private[this] def jList[A](as: A*): ju.List[A] = {
    val lst = new ju.ArrayList[A](as.size)
    as.foreach(lst.add)
    lst
  }
}

private[avro] object CompiledSemanticsAvroPluginTest {
  implicit class ToGenericRecord(val r: Any) extends AnyVal {
    def asGR: Option[GenericRecord] = Option(r) collect { case r: GenericRecord => r }
  }

  lazy val Schemas: Vector[avro.Schema] = {
    val is = VFS.getManager.resolveFile("res:avro/test.avpr").getContent.getInputStream
    try {
      val protocol = Protocol.parse(is)
      val schemas = protocol.getTypes.toVector.reverse
      schemas
    }
    finally {
      IOUtils.closeQuietly(is)
    }
  }

  /**
    * A serialization round trip ensures that everything adheres to the top-level schema.
    */
  lazy val genRecords = serializationRoundTrip((0 to levels).map(testGenRecord), Schemas(0))

  val numRepeats = 2
  val levels = 7

  val boolVal = true
  val strVal = "test"
  val intVal = 3
  val longVal = 4L
  val floatVal = 5f
  val doubleVal = 6d

  def repeatedSeq(level: Int) = (0 until numRepeats).map(2 + level * 10 + _)
  def optVal(level: Int) = Option(10 * level)

  /** Get a testGenRecord filled in for user in tests.
    * @param m 0 <= m <= levels.  The number of levels to fill in.
    * @return
    */
  def testGenRecord(m: Int) = {
    require(0 <= m && m <= levels, "Expected 0 <= m <= " + levels + ". Found " + m)
    val o = (0 until m).map(optVal) ++ Seq.fill(levels - m)(None)
    val s = (0 until m).map(repeatedSeq) ++ Seq.fill(levels - m)(Nil)
    val b0 = fillClassInts(0, o(0),  1, s(0):_*)
    b0.put("req_str_1", strVal)
    b0.put("rep_str_1", Seq(strVal).asJava)

    val b1 = fillClassInts(1, o(1), 11, s(1):_*)
    val b2 = fillClassInts(2, o(2), 21, s(2):_*)
    val b3 = fillClassInts(3, o(3), 31, s(3):_*)
    val b4 = fillClassInts(4, o(4), 41, s(4):_*)
    val b5 = fillClassInts(5, o(5), 51, s(5):_*)
    val b6 = fillClassInts(6, o(6), 61, s(6):_*)

    // Put the repeated strings in Class3.
    b2.put("rep_str_3", asJavaIterable(1 to 3 map (_.toString)))
    b2.put("opt_rep_str_3", asJavaIterable(1 to 3 map (_.toString)))

    if (6 < m) { b5.put("opt_c6", b6); b5.put("rep_c6", asJavaIterable(Seq.fill(s(5).size)(b6))) } else b5.put("rep_c6", asJavaIterable(Iterable()))
    b5.put("req_c6", b6)
    if (5 < m) { b4.put("opt_c5", b5); b4.put("rep_c5", asJavaIterable(Seq.fill(s(4).size)(b5))) } else b4.put("rep_c5", asJavaIterable(Iterable()))
    b4.put("req_c5", b5)
    if (4 < m) { b3.put("opt_c4", b4); b3.put("rep_c4", asJavaIterable(Seq.fill(s(3).size)(b4))) } else b3.put("rep_c4", asJavaIterable(Iterable()))
    b3.put("req_c4", b4)
    if (3 < m) { b2.put("opt_c3", b3); b2.put("rep_c3", asJavaIterable(Seq.fill(s(2).size)(b3))) } else b2.put("rep_c3", asJavaIterable(Iterable()))
    b2.put("req_c3", b3)
    if (2 < m) { b1.put("opt_c2", b2); b1.put("rep_c2", asJavaIterable(Seq.fill(s(1).size)(b2))) } else b1.put("rep_c2", asJavaIterable(Iterable()))
    b1.put("req_c2", b2)
    if (1 < m) { b0.put("opt_c1", b1); b0.put("rep_c1", asJavaIterable(Seq.fill(s(0).size)(b1))) } else b0.put("rep_c1", asJavaIterable(Iterable()))
    b0.put("req_c1", b1)

    b0.put("ob", boolVal)
    b0.put("os", strVal)
    b0.put("oi", intVal)
    b0.put("ol", longVal)
    b0.put("of", floatVal)
    b0.put("od", doubleVal)

    b0
  }

  def fillClassInts(level: Int, o: Option[Int], r: Int, l: Int*) = {
    val id = level + 1
    val schema = Schemas(level)
    val rec = new GenericData.Record(schema)
    o foreach { rec.put(s"opt_int_$id", _) }
    rec.put(s"req_int_$id", r)
    rec.put(s"rep_int_$id", asJavaIterable(l))
    rec
  }

  def serializationRoundTrip(records: Seq[GenericRecord], schema: avro.Schema): Vector[GenericData.Record] = {
    val datumWriter = new GenericDatumWriter[GenericRecord](schema)
    val f = File.createTempFile("avrotest", ".dat")
    f.deleteOnExit()

    // Serialize
    val fileWriter = new DataFileWriter(datumWriter)
    fileWriter.create(schema, f)
    records.foreach(fileWriter.append)
    fileWriter.close()

    // Deserialize
    val datumReader = new GenericDatumReader[GenericRecord](schema)
    val dataFileReader = new DataFileReader(f, datumReader)
    val deserializedRecords = dataFileReader.iterator().toVector
    dataFileReader.close()

    // Unsafe cast but it is true.
    deserializedRecords.asInstanceOf[Vector[GenericData.Record]]
  }
}
