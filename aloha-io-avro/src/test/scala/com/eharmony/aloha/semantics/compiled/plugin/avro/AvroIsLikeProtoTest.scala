package com.eharmony.aloha.semantics.compiled.plugin.avro

import java.io.File

import com.eharmony.aloha.audit.impl.OptionAuditor
import com.eharmony.aloha.factory.ModelFactory
import com.eharmony.aloha.models.reg.RegressionModel
import com.eharmony.aloha.reflect.{RefInfo, RefInfoOps}
import com.eharmony.aloha.semantics.compiled.CompiledSemantics
import com.eharmony.aloha.semantics.compiled.compiler.TwitterEvalCompiler
import org.apache.avro
import org.apache.avro.Protocol
import org.apache.avro.file.{DataFileReader, DataFileWriter}
import org.apache.avro.generic.{GenericData, GenericDatumReader, GenericDatumWriter, GenericRecord}
import org.apache.avro.util.Utf8
import org.apache.commons.io.IOUtils
import org.apache.commons.vfs2.VFS
import org.junit.Assert._
import org.junit.Test

import scala.collection.JavaConversions.{asJavaIterable, asScalaIterator, collectionAsScalaIterable, iterableAsScalaIterable}

/**
  * Created by ryan.
  */
class AvroIsLikeProtoTest {
  import AvroIsLikeProtoTest._

  private[this] lazy val plugin = CompiledSemanticsAvroPlugin[GenericRecord](Schemas(0))

  private[this] lazy val semantics = {
    import concurrent.ExecutionContext.Implicits.global
    // Provide a cache for the classes generated by the compiler.
    CompiledSemantics(
      TwitterEvalCompiler(
      //  classCacheDir = Option(FileLocations.testGeneratedClasses)
      ),
      plugin = plugin,
      imports = Seq("com.eharmony.aloha.feature.BasicFunctions._"))
  }

  @Test def testRequiredChains() {
    for {
      i <- 1 to levels
      s = "${" + (1 until i).map("req_c" + _ + ".").mkString("") + "req_int_" + i + "}"
      ff = semantics.createFunction[Int](s)
      f = ff.right.toOption.get
      j = i - 1
    } assertEquals("testRequiredChains, case " + j, 10 * j + 1, f(genRecords(j)))
  }

  // TODO: fix so that type is Seq[Int] instead of Seq[Integer]
  @Test def testRequiredChainsWithRepeated() {
    for {
      i <- 1 to levels
      s = "${" + (1 until i).map("req_c" + _ + ".").mkString + "rep_int_" + i + "}"
      f = semantics.createFunction[Seq[Int]](s).right.toOption.get
    } assertEquals("testRequiredChainsWithRepeated, case " + i, Seq.range(0, numRepeats).map(_ + 10 * (i - 1) + 2), f(genRecords(i)))
  }

  @Test def test_O() {
    val missing = Int.MinValue
    val s = "${opt_int_1}"
    val f = semantics.createFunction[Int](s, Option(missing)).right.toOption.get
    assertEquals(0, f(genRecords.last))
    assertEquals(missing, f(genRecords.head))
  }

  @Test def testStringEscaping() {
    val s = "${req_str_1} == \"" + strVal + "\""
    val f = semantics.createFunction[Boolean](s).right.get
    val v = f(genRecords.head)
    assertTrue("in testStringEscaping...", v)
  }

  /** Construct a ''Map[Int, Float](0 -> 0, 10 -> 0.1, ..., 50 -> 0.5)'',  Then use the value extracted from the
    * proto as a lookup into the map.
    */
  @Test def test_map() {
    // The else here makes the final generated function a non-Optional function.  Whether that non-optional is
    // optionally applied is up to the existence of ${opt_c1.opt_c2.opt_c3.opt_int_4}.  This is why we supply a
    // default to the createFunction function.
    val s = "0.to(50, 10).map(i => (i, i / 100f)).toMap.getOrElse(${opt_c1.opt_c2.opt_c3.opt_int_4}, Float.NegativeInfinity)"

    // Only here for readability.  Want to show that applying f gives 1/100 of this value.
    val expC4 = 30

    val actC4 = for {
      c1 <- genRecords.last.get("opt_c1").asGR
      c2 <- c1.get("opt_c2").asGR
      c3 <- c2.get("opt_c3").asGR
      c4 <- Option(c3.get("opt_int_4")) collect { case i: Integer => i.intValue() }
    } yield c4

    assertEquals(expC4, actC4.get)

    val f = semantics.createFunction[Float](s, Option(Float.NaN)).right.toOption.get
    assertEquals(expC4 / 100f, f(genRecords.last), 1.0e-5)
  }

  /**
    * '''NOTE''': The output type of the function is Seq[Int].  This is because there is no casting of the value type
    * AND implicit wrapping of container class.  This differs from the protocol buffer implementation.
    */
  @Test def test_L() {
    val s = "${rep_int_1}"
    val f = semantics.createFunction[Seq[Int]](s).right.toOption.get
    assertEquals(Seq(2, 3), f(genRecords.last))
  }

  /** An optional list of an optional field should map to a list of options.
    */
  @Test def test_OLO() {
    val testCase = genRecords(4)

    val exp = (for {
      c1 <- testCase.get("opt_c1").asGR
      c2 <- Option(c1.get("rep_c2").asInstanceOf[java.lang.Iterable[GenericRecord]])
    } yield c2.toSeq.map(v => Option(v.get("opt_int_3")).asInstanceOf[Option[Int]])).get

    // Because opt_int_3 is an 'optional int32' in the proto definition, and rep_c2 is repeated
    // the resulting type is a sequence of Option of Int.
    val s = "${opt_c1.rep_c2.opt_int_3}"
    val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get

    val act = f(testCase)
    assertEquals(exp, act)
  }

  @Test def test_OROLOOR() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4.opt_c5.opt_c6.req_int_7}"
    val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get
    assertEquals(Seq.fill(2)(Some(61)), f(genRecords.last))
  }

  @Test def test_OROLOOO() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4.opt_c5.opt_c6.opt_int_7}"
    val f = semantics.createFunction[Seq[Option[Int]]](s).right.toOption.get
    assertEquals(Seq.fill(2)(Some(60)), f(genRecords.last))
  }

  @Test def test_OROL() {
    val s = "${opt_c1.req_c2.opt_c3.rep_c4}"
    val ff = semantics.createFunction[Seq[GenericRecord]](s)
    ff.left.foreach("test_OROL: " + _)
    val f = ff.right.toOption.get

    val exp = (for {
      last <- Option(genRecords.last)
      c1 <- last.get("opt_c1").asGR
      c2 <- c1.get("req_c2").asGR
      c3 <- c2.get("opt_c3").asGR
      c4 <- Option(c3.get("rep_c4")).asInstanceOf[Option[java.lang.Iterable[GenericRecord]]].map(it => it.toSeq)
    } yield c4).get


    assertEquals(exp, f(genRecords.last))
  }

  /**
    * Test that an optional list is compiled
    */
  @Test def testOptionalListOfReq(): Unit = {
    val sum = semantics.createFunction[Int]("${orep_int_1}.sum").right.get
    val s = sum(genRecords.last)
    assertEquals(0, s)
  }

  /**
    * Test that an optional list is compiled
    */
  @Test def testOptionalListOfOpt(): Unit = {
    val sumOpt = semantics.createFunction[Int]("${orep_oint_1}.flatten.sum")
    val sum  = sumOpt.right.get
    val s = sum(genRecords.last)
    assertEquals(0, s)
  }

  private[this] def testType[A: RefInfo](field: String, value: Any): Unit = {
    val v =
      if (value.isInstanceOf[String])
        s""""${value.toString}""""
      else value.toString

    val t = RefInfoOps.toString[A]
    val code = "${" + field + "}.isInstanceOf[" + t + "] && ${" + field + "} == " + v
    val check = semantics.createFunction[Boolean](code, Some(false)).right.get

    assertTrue(s"Something is wrong with $t functions.  code: $code", check(genRecords.last))
  }

  @Test def testOptionalBoolean(): Unit = testType[Boolean]("ob", boolVal)
  @Test def testOptionalString(): Unit = testType[String]("os", strVal)
  @Test def testOptionalInt(): Unit = testType[Int]("oi", intVal)
  @Test def testOptionalLong(): Unit = testType[Long]("ol", longVal)
  @Test def testOptionalFloat(): Unit = testType[Float]("of", floatVal)
  @Test def testOptionalDouble(): Unit = testType[Double]("od", doubleVal)


  // This stuff that follows isn't really necessary.

  private[this] def bagOfWordsRecord = {
    val r = new GenericData.Record(genRecords.last, true)
    r.put("req_str_1", new Utf8("handsome smart stubborn"))
    r
  }

  @Test def test_BagOfWords1() {
    val s = """${req_str_1}.split("\\W+").zip(Stream continually 1.0)"""
    val f = semantics.createFunction[Iterable[(String, Double)]](s).right.toOption.get

    val a = f(bagOfWordsRecord).toSet
    assertEquals(Set(("handsome", 1.0), ("smart", 1.0), ("stubborn", 1.0)), a)
  }

  @Test def test_BagOfWords2() {
    val f = ModelFactory.defaultFactory(semantics, OptionAuditor[Double]())

    val m = f.fromString(
      """
        |{
        |  "modelType": "Regression",
        |  "modelId": { "id": 0, "name": "" },
        |  "features" : {
        |    "my_attributes": "${req_str_1}.split(\"\\\\W+\").map(v => (s\"=$v\", 1.0))"
        |  },
        |  "weights": {
        |    "my_attributes=handsome": 1,
        |    "my_attributes=smart": 2,
        |    "my_attributes=stubborn": 4
        |  }
        |}
      """.stripMargin).get

    val v = m(bagOfWordsRecord)
    assertEquals(7d, v.get, 0)
  }
}

private[avro] object AvroIsLikeProtoTest {
  implicit class ToGenericRecord(val r: Any) extends AnyVal {
    def asGR: Option[GenericRecord] = Option(r) collect { case r: GenericRecord => r }
  }

  lazy val Schemas: Vector[avro.Schema] = {
    val is = VFS.getManager.resolveFile("res:avro/test.avpr").getContent.getInputStream
    try {
      val protocol = Protocol.parse(is)
      val schemas = protocol.getTypes.toVector.reverse
      schemas
    }
    finally {
      IOUtils.closeQuietly(is)
    }
  }

  /**
    * A serialization round trip ensures that everything adheres to the top-level schema.
    */
  lazy val genRecords = serializationRoundTrip((0 to levels).map(testGenRecord), Schemas(0))

  val numRepeats = 2
  val levels = 7

  val boolVal = true
  val strVal = "test"
  val intVal = 3
  val longVal = 4L
  val floatVal = 5f
  val doubleVal = 6d

  def repeatedSeq(level: Int) = (0 until numRepeats).map(2 + level * 10 + _)
  def optVal(level: Int) = Option(10 * level)

  /** Get a testGenRecord filled in for user in tests.
    * @param m 0 <= m <= levels.  The number of levels to fill in.
    * @return
    */
  def testGenRecord(m: Int) = {
    require(0 <= m && m <= levels, "Expected 0 <= m <= " + levels + ". Found " + m)
    val o = (0 until m).map(optVal) ++ Seq.fill(levels - m)(None)
    val s = (0 until m).map(repeatedSeq) ++ Seq.fill(levels - m)(Nil)
    val b0 = fillClassInts(0, o(0),  1, s(0):_*)
    b0.put("req_str_1", strVal)

    val b1 = fillClassInts(1, o(1), 11, s(1):_*)
    val b2 = fillClassInts(2, o(2), 21, s(2):_*)
    val b3 = fillClassInts(3, o(3), 31, s(3):_*)
    val b4 = fillClassInts(4, o(4), 41, s(4):_*)
    val b5 = fillClassInts(5, o(5), 51, s(5):_*)
    val b6 = fillClassInts(6, o(6), 61, s(6):_*)

    if (6 < m) { b5.put("opt_c6", b6); b5.put("rep_c6", asJavaIterable(Seq.fill(s(5).size)(b6))) } else b5.put("rep_c6", asJavaIterable(Iterable()))
    b5.put("req_c6", b6)
    if (5 < m) { b4.put("opt_c5", b5); b4.put("rep_c5", asJavaIterable(Seq.fill(s(4).size)(b5))) } else b4.put("rep_c5", asJavaIterable(Iterable()))
    b4.put("req_c5", b5)
    if (4 < m) { b3.put("opt_c4", b4); b3.put("rep_c4", asJavaIterable(Seq.fill(s(3).size)(b4))) } else b3.put("rep_c4", asJavaIterable(Iterable()))
    b3.put("req_c4", b4)
    if (3 < m) { b2.put("opt_c3", b3); b2.put("rep_c3", asJavaIterable(Seq.fill(s(2).size)(b3))) } else b2.put("rep_c3", asJavaIterable(Iterable()))
    b2.put("req_c3", b3)
    if (2 < m) { b1.put("opt_c2", b2); b1.put("rep_c2", asJavaIterable(Seq.fill(s(1).size)(b2))) } else b1.put("rep_c2", asJavaIterable(Iterable()))
    b1.put("req_c2", b2)
    if (1 < m) { b0.put("opt_c1", b1); b0.put("rep_c1", asJavaIterable(Seq.fill(s(0).size)(b1))) } else b0.put("rep_c1", asJavaIterable(Iterable()))
    b0.put("req_c1", b1)

    b0.put("ob", boolVal)
    b0.put("os", strVal)
    b0.put("oi", intVal)
    b0.put("ol", longVal)
    b0.put("of", floatVal)
    b0.put("od", doubleVal)

    b0
  }

  def fillClassInts(level: Int, o: Option[Int], r: Int, l: Int*) = {
    val id = level + 1
    val schema = Schemas(level)
    val rec = new GenericData.Record(schema)
    o foreach { rec.put(s"opt_int_$id", _) }
    rec.put(s"req_int_$id", r)
    rec.put(s"rep_int_$id", asJavaIterable(l))
    rec
  }

  def serializationRoundTrip(records: Seq[GenericRecord], schema: avro.Schema): Vector[GenericData.Record] = {
    val datumWriter = new GenericDatumWriter[GenericRecord](schema)
    val f = File.createTempFile("avrotest", ".dat")
    f.deleteOnExit()

    // Serialize
    val fileWriter = new DataFileWriter(datumWriter)
    fileWriter.create(schema, f)
    records.foreach(fileWriter.append)
    fileWriter.close()

    // Deserialize
    val datumReader = new GenericDatumReader[GenericRecord](schema)
    val dataFileReader = new DataFileReader(f, datumReader)
    val deserializedRecords = dataFileReader.iterator().toVector
    dataFileReader.close()

    // Unsafe cast but it is true.
    deserializedRecords.asInstanceOf[Vector[GenericData.Record]]
  }
}
